.ignorecase = 0
.template 0

function modifyTypeName(type)
  return string.replace(my.type, "MPI_|TAMPI_")
endfunction

function addHandleData(handle, name, type)
  new my.handle.item
    define item.name = my.name
    define item.type = my.type
  endnew
endfunction

for functions.function as curFunction
 #generate the constants for each function
 curFunction.handleName = "TAMPI_$(curFunction.name)_Handle"
 if(!defined(curFunction.mpiName))
  curFunction.mpiName = "MPI_$(curFunction.name)"
 endif

 # mark all orignal arguments as args
 for curFunction. as item
   item.arg = 1
 endfor
 #generate the names for the datatypes
 for curFunction.send
   send.typeName = "$(send.type:upper)"
 endfor
 for curFunction.recv
   recv.typeName = "$(recv.type:upper)"
 endfor

# build the definitions for the templates
 curFunction.tplDef = ""
 curFunction.tplArg = ""
 curFunction.tplArgMod = ""
 curFunction.tplEmpty = ""
 for curFunction.type
   type.tplName = "$(type.name:upper)"
   curFunction.tplDef += "typename $(type.tplName)"
   curFunction.tplArg += "$(type.tplName)"
   curFunction.tplArgMod += "typename $(type.tplName)::ModifiedNested"
   curFunction.tplEmpty += "EmptyDataType"

   comma = last()?? "" ? ", "
   curFunction.tplDef += comma
   curFunction.tplArg += comma
   curFunction.tplArgMod += comma
   curFunction.tplEmpty += comma
 endfor

# build the TAMPI names for all arguments
 for curFunction. as item
   item.taType = modifyTypeName(item.type)
 endfor

#build the argument lists and the list for the handles
 curFunction.argDef = ""
 curFunction.argArg = ""
 curFunction.argRev = ""
 curFunction.argEmpty = ""
 for curFunction. as item where defined(item.arg)
   constMod = defined(item.const) ?? "const " ? ""
   curFunction.argDef +=   constMod # prepend the const modifier
   curFunction.argEmpty +=   constMod # prepend the const modifier
   if(name(item) <> "type")  # exclude the types because they are handled as templates
     if(name(item) =  "recv" | name(item) =  "send")
       curFunction.argDef += "typename $(item.typeName)::Type* $(item.name)"  #append '::Type' to the typename
       curFunction.argArg += "$(item.name)Mod"    # append 'Mod' to the bufferNames
       if(defined(item.displs))
         curFunction.argRev += "$(item.name)Adjoints, $(item.name)Primals, h->$(item.name)Count, h->$(item.name)Displs, $(item.name)Type"    # append adjoint and primal buffer and the byte size
       else
         curFunction.argRev += "$(item.name)Adjoints, $(item.name)Primals, $(item.name)Size, $(item.name)Type"    # append adjoint and primal buffer and the byte size
       endif
       curFunction.argEmpty += "typename EmptyDataType::Type* $(item.name)"
     elsif(name(item) = "operator")
       curFunction.argDef += "$(item.taType) $(item.name)"
       curFunction.argArg += "*$(item.name).modifiedOp"
       curFunction.argRev += "$(item.name)"
       curFunction.argEmpty += "$(item.taType) $(item.name)"
     elsif(name(item) = "displs")
       curFunction.argDef += "$(item.taType) $(item.name)"
       curFunction.argArg += "$(item.name)Mod"
       curFunction.argRev += "$(item.name)"
       curFunction.argEmpty += "$(item.taType) $(item.name)"
     else
       curFunction.argDef += "$(item.taType) $(item.name)"
       curFunction.argArg += "$(item.name)"
       curFunction.argRev += "$(item.name)"
       curFunction.argEmpty += "$(item.taType) $(item.name)"
     endif
     comma = last()?? "" ? ", "
     curFunction.argDef += comma
     curFunction.argArg += comma
     curFunction.argRev += comma
     curFunction.argEmpty += comma
   endif
 endfor

 new curFunction.primalHandle as handle
   define handle.noarg = 1
 endnew
 new curFunction.reverseHandle as handle
   define handle.noarg = 1
 endnew
 for curFunction. as item where defined(item.arg)
   if(name(item) <> "type")  # exclude the types because they are handled as templates
     constMod = defined(item.const) ?? "const " ? ""
     if(name(item) =  "recv" | name(item) =  "send")
       addHandleData(curFunction->reverseHandle, "$(item.name)", "$(constMod) typename $(item.typeName)::Type*")  # change back
       addHandleData(curFunction->reverseHandle, "$(item.name)Mod", "typename $(item.typeName)::ModifiedType*")  # change back
       addHandleData(curFunction->reverseHandle, "$(item.name)TotalSize", "int")
       addHandleData(curFunction->reverseHandle, "$(item.name)Indices", "typename $(item.typeName)::IndexType*")
       addHandleData(curFunction->reverseHandle, "$(item.name)Primals", "typename $(item.typeName)::PassiveType*")
       addHandleData(curFunction->reverseHandle, "$(item.name)Adjoints", "/* required for async */ typename $(item.typeName)::PassiveType*")
       addHandleData(curFunction->reverseHandle, "$(item.name)PrimalsReverse", "/* required for async */ typename $(item.typeName)::PassiveType*")
       if(defined(item.displs))
         addHandleData(curFunction->reverseHandle, "$(item.name)Count", "int*")
         addHandleData(curFunction->reverseHandle, "$(item.name)Displs", "int*")
         addHandleData(curFunction->reverseHandle, "$(item.displs)Mod", "const int*")
       else
         addHandleData(curFunction->reverseHandle, "$(item.name)Count", "int")
       endif
     elsif(name(item) = "request")
       addHandleData(curFunction->reverseHandle, "$(item.name)", "$(item.taType)") # change back
       addHandleData(curFunction->reverseHandle, "$(item.name)Reverse", "TAMPI_Request")
     else
       # add other items to both handles
       addHandleData(curFunction->primalHandle, "$(item.name)", "$(constMod) $(item.taType)")
       addHandleData(curFunction->reverseHandle, "$(item.name)", "$(constMod) $(item.taType)")
     endif
   endif
 endfor

#build the argument list for the regular call
 curFunction.argReg = ""
 for curFunction. as item where defined(item.arg)

   if(name(item) = "type")
     curFunction.argReg += "$(item.tplName)::Tool::MPIType"    # get the regular mpi type
   elsif(name(item) = "operator")
     curFunction.argReg += "$(item.name).primalFunction"    # get the regular mpi type
   elsif(name(item) = "request")
     curFunction.argReg += "&$(item.name)->request"
   else
     curFunction.argReg += "$(item.name)"
   endif
   curFunction.argReg += last()?? "" ? ", "  # append the seperator if neede
 endfor

# add properties to the buffers
 for curFunction. as item where defined(item.arg)

   if(name(item) =  "recv" | name(item) =  "send")
     item.rankCount = "1"
     if(defined(item.ranks) | defined(item.displs))
       item.rankCount = "getCommSize(comm)"
     endif

   endif
 endfor

 # link inplace buffers together
 for curFunction. as item where defined(item.arg)

   if(name(item) =  "recv" | name(item) =  "send")
     if(defined(item.inplace))
       for curFunction. as linkedItem where defined(linkedItem.arg)

         if(linkedItem.name = item.inplace)
           # found the buffer with the name so copy it to this buffer and create the link
           copy linkedItem to item as inplaceBuffer
         endif
       endfor
     endif
   endif
 endfor

 # define the ad type that is used in this function
 curFunction.adType = "$(curFunction->type.tplName)::Tool"

 # define the main type that is used in this function
 curFunction.mainType = "$(curFunction->type.tplName)"
endfor

function startRoot(buffer)
  if(defined(my.buffer.root))  # check if this buffer is only required on the root process
>      if($(my.buffer.root) == getCommRank(comm)) {
  endif
endfunction

function endRoot(buffer)
  if(defined(my.buffer.root))
>      }
  endif
endfunction

# createBufferAccessLogic
# @param[in] modifiedCheck  Adds a check if modifed buffers are required.
#                            0 -> no check
#                            1 -> add positive check (exectued if modified buffers are required)
#                           -1 -> add negative check (executed if no modified buffers are required)
function createBufferAccessLogic(buffer, modifiedCheck, access)
  startRoot(my.buffer)
  if(1 = my.modifiedCheck)
>  if($(my.buffer.typeName)::IS_RequiresModifiedBuffer) {
  elsif(-1 = my.modifiedCheck)
>  if(!$(my.buffer.typeName)::IS_RequiresModifiedBuffer) {
  endif
     if(defined(my.buffer.inplace))
>      if(TAMPI_IN_PLACE != $(my.buffer.name)) {
     endif
     generateLoop(my.buffer, my.access)
     if(defined(my.buffer.inplace))
>     } else {
        inplaceBuffer = my.buffer->inplaceBuffer
        generateInplaceLoop(my.buffer, inplaceBuffer, my.access)
>     }
     endif
  if(0 <> my.modifiedCheck)
>  }
  endif
  endRoot(my.buffer)
endfunction


function createBufferElementsComputation(buffer)
  if(defined(my.buffer.inplace))
>   if(TAMPI_IN_PLACE != $(my.buffer.name)) {
  endif
# the buffer is defined
  if(defined(my.buffer.displs))
>   $(my.buffer.name)Elements = $(my.buffer.displs)TotalSize;
  elsif(defined(my.buffer.ranks))
>   $(my.buffer.name)Elements = $(my.buffer.count) * getCommSize($(my.buffer.ranks));
  else
>   $(my.buffer.name)Elements = $(my.buffer.count);
  endif
  if(defined(my.buffer.inplace))
    inplaceBuffer = my.buffer->inplaceBuffer
>   } else {

    # The buffer is an inplace buffer
    if(defined(inplaceBuffer.displs))
      if(defined(my.buffer.displs)) # both have the same layout so copy the total size
>       $(my.buffer.name)Elements = $(inplaceBuffer.displs)TotalSize;
      else  # buffer is a normal buffer so just get the size from the rank
>       $(my.buffer.name)Elements = $(inplaceBuffer.count)[getCommRank(comm)];
      endif
    elsif(defined(inplaceBuffer.ranks))
      if(defined(my.buffer.ranks)) # both have the same layout so copy the total size
>       $(my.buffer.name)Elements = $(inplaceBuffer.count) * getCommSize($(my.buffer.ranks));
      else # buffer is a normal buffer so just get the size from the rank
>       $(my.buffer.name)Elements = $(inplaceBuffer.count);
      endif
    else
>     $(my.buffer.name)Elements = $(inplaceBuffer.count);
    endif
>   }
  endif
endfunction

function createBufferReverseSetup(buffer, curFunction, isRecv)
> $(my.buffer.name)Adjoints = NULL;
> $(my.buffer.name)Primals = NULL;
> int $(my.buffer.name)Size = 0;
> MPI_Datatype $(my.buffer.name)Type = MPI_DOUBLE;
  startRoot(my.buffer)
    allMul = ""
    if(defined(my.buffer.all))
      allMul = "* getCommSize($(my.buffer.all))"
    endif
>   allocateReverseBuffer($(my.buffer.name)Adjoints, $(my.buffer.name)Primals, h->$(my.buffer.name)Count, h->$(my.buffer.name)TotalSize $(allMul), $(primalRequired), $(my.buffer.name)Size, $(my.buffer.name)Type);
    if(1 = my.isRecv)
>     $(my.buffer.typeName)::getAdjoints(h->$(my.buffer.name)Indices, h->$(my.buffer.name)TotalSize, $(my.buffer.name)Adjoints);
>
      if(defined(my.curFunction->operator))
>       $(my.curFunction->operator.name).preAdjointOperation($(my.buffer.name)Adjoints, h->$(my.buffer.name)Primals, h->$(my.buffer.name)Count);
>       if($(primalRequired)) {
>         copyPrimals($(my.buffer.name)Primals, h->$(my.buffer.name)Primals, h->$(my.buffer.name)Count);
>       }
      endif
    endif
  endRoot(my.buffer)
endfunction

function createBufferReverseCleanup(buffer, curFunction, isSend)
  startRoot(my.buffer)
    if(1 = my.isSend)
      if(defined(my.curFunction->operator))
>       $(my.curFunction->operator.name).postAdjointOperation($(my.buffer.name)Adjoints, h->$(my.buffer.name)Primals, $(my.buffer.name)Primals, h->$(my.buffer.name)TotalSize);
      endif
      if(defined(my.buffer.all))
>       combineAdjoints(h->$(my.buffer.name)TotalSize, $(my.buffer.name)Adjoints, getCommSize($(my.buffer.all)));
      endif
>     $(my.buffer.typeName)::updateAdjoints(h->$(my.buffer.name)Indices, h->$(my.buffer.name)TotalSize, $(my.buffer.name)Adjoints);
    endif
>   deleteReverseBuffer($(my.buffer.name)Adjoints , $(my.buffer.name)Primals, $(primalRequired));
  endRoot(my.buffer)
endfunction

# define function for primal extraction
function createPrimalExtraction(buffer)
  startRoot(my.buffer)
>   const typename $(my.buffer.typeName)::Type* tempBuf = $(my.buffer.name);
    if(defined(my.buffer.inplace))
>     if(MPI_IN_PLACE == tempBuf) {
>       tempBuf = $(my.buffer.inplace);
>     }
    endif
>   $(my.buffer.typeName)::getValues(tempBuf, $(my.buffer.count), h->$(my.Buffer.name)Primals);
  endRoot(my.buffer)
endfunction

function outputStatement(statement, typeName, name, pos, linPos, startLinPos, count)
> $(string.replace(my.statement, "$typeName$|$(my.typeName),$name$|$(my.name),$pos$|$(my.pos),$linPos$|$(my.linPos),$startLinPos$|$(my.startLinPos),$curCount$|$(my.count)"))
endfunction

#create a loop around a statement
function generateLoop(buffer, statement)
  if(defined(my.buffer.displs))
>   for(int i = 0; i < getCommSize(comm); ++i) {
      pos = "$(my.buffer.displs)[i]"
      linPos = "$(my.buffer.displs)Mod[i]"
      curCount = "$(my.buffer.count)[i]"
      outputStatement(my.statement, my.buffer.typeName, my.buffer.name, pos, linPos, linPos, curCount)
>   }
  elsif(defined(my.buffer.ranks))
    outputStatement(my.statement, my.buffer.typeName, my.buffer.name, "0", "0", "0", "$(my.buffer.count) * getCommSize($(my.buffer.ranks))")
  else
    outputStatement(my.statement, my.buffer.typeName, my.buffer.name, "0", "0", "0", "$(my.buffer.count)")
  endif
endfunction

#create a loop around a statement
function generateInplaceLoop(buffer, inplaceBuffer, statement)
  if(defined(my.buffer.displs) | defined(my.buffer.ranks))
    # this buffer has a special layout so the other buffer must have the same layout
    generateLoop(my.inplaceBuffer, my.statement)
  elsif(defined(my.inplaceBuffer.displs))
>   {
      # TODO: add marker for displacement buffers, that indicates the communicator
>     const int rank = getCommRank(comm);
      pos = "$(my.inplaceBuffer.displs)[rank]"
      linPos = "$(my.inplaceBuffer.displs)Mod[rank]"
      curCount = "$(my.inplaceBuffer.count)[rank]"
      outputStatement(my.statement, my.inplaceBuffer.typeName, my.inplaceBuffer.name, pos, linPos, "0", curCount)
>   }
  elsif(defined(my.inplaceBuffer.ranks))
     pos = "$(my.inplaceBuffer.count) * getCommRank($(my.inplaceBuffer.ranks))"
     curCount = "$(my.inplaceBuffer.count)"
    outputStatement(my.statement, my.inplaceBuffer.typeName, my.inplaceBuffer.name, pos, pos, "0", curCount)
  else
    generateLoop(my.inplaceBuffer, my.statement)
  endif
endfunction

function unpackHandle(curFunction, reverse)
>   $(my.curFunction.handleName)<$(my.curFunction.tplArg)>* h = static_cast<$(my.curFunction.handleName)<$(my.curFunction.tplArg)>*>(handle);
# unpack the arguments (buffers are accessed directly)
  for my.curFunction. as item where defined(item.arg)
    if(name(item) <> "type")
      constMod = defined(item.const) ?? "const " ? ""
      if(name(item) = "send" | name(item) = "recv")
        if(1 = my.reverse)
>        typename $(item.typeName)::PassiveType* $(item.name)Adjoints = h->$(item.name)Adjoints;
>        typename $(item.typeName)::PassiveType* $(item.name)Primals = h->$(item.name)PrimalsReverse;
        else
>        $(constMod)typename $(item.typeName)::Type* $(item.name) = h->$(item.name);
>        typename $(item.typeName)::ModifiedType* $(item.name)Mod = h->$(item.name)Mod;
         if(defined(item.displs))
>         const int* $(item.displs)Mod = h->$(item.displs)Mod;
         endif
        endif
      elsif(name(item) = "request")
        if(1 = my.reverse)
>         $(item.taType) $(item.name) = &h->$(item.name)Reverse;
        else
>         $(item.taType) $(item.name) = h->$(item.name);
        endif
      else
>         $(constMod)$(item.taType) $(item.name) = h->$(item.name);
      endif
    endif
  endfor
endfunction

function packHandle(curFunction, reverse)
# pack the arguments
  for my.curFunction->handle. as item
    if(1 = my.reverse)
      out = item.reverse
    else
      out = item.primal
    endif

    if(out)
>     h->$(item.name) = $(item.name);
    endif
  endfor
endfunction

function addPrimalAsyncSplit(curFunction)
  if(defined(my.curFunction.async))
>      $(my.curFunction.async)->handle = h;
>      $(my.curFunction.async)->func = (ContinueFunction)TAMPI_$(my.curFunction.name)_finish<$(my.curFunction.tplArg)>;
>      if(NULL != h) {
>        WaitHandle* waitH = new WaitHandle((ContinueFunction)TAMPI_$(my.curFunction.name)_b_finish<$(my.curFunction.tplArg)>, h);
>        $(my.curFunction.adType)::addToolAction(waitH);
>      }
>    }
>
>    return rStatus;
>  }
>
>  template<$(my.curFunction.tplDef)>
>  int TAMPI_$(my.curFunction.name)_finish(HandleBase* handle) {
>    int rStatus = 0;
>    if($(my.curFunction.adType)::IS_ActiveType) {
    unpackHandle(my.curFunction, 0)
>
  endif
endfunction

function addReverseAsyncSplit(curFunction)
  if(defined(my.curFunction.async))
  for my.curFunction. as item
    if(name(item) = "send" | name(item) = "recv")
>     h->$(item.name)Adjoints = $(item.name)Adjoints;
>     h->$(item.name)PrimalsReverse = $(item.name)Primals;
    endif
  endfor
>  }
>
>  template<$(my.curFunction.tplDef)>
>  void TAMPI_$(my.curFunction.name)_b_finish(HandleBase* handle) {
    unpackHandle(my.curFunction, 1)
    for my.curFunction. as item
      if(name(item) = "send" | name(item) = "recv")
        if(defined(item.displs))
>         int $(item.name)TotalSize = h->$(item.name)TotalSize;
        else
>         int $(item.name)TotalSize = h->$(item.name)Count * $(item.rankCount);
        endif
      endif
    endfor
>
>    MPI_Wait(&$(my.curFunction.async)->request, MPI_STATUS_IGNORE);
>
  endif
endfunction

.endtemplate
.output "$(switches.arg1)"
#pragma once

#include "../include/medipack.h"
#include "../include/reverseFunctions.hpp"
#include "../include/tampi/async.hpp"

namespace medi {
.for functions.function as curFunction
.- create the struct for the data store
  template<$(curFunction.tplDef)>
  struct $(curFunction.handleName) : public HandleBase {
. for curFunction->reverseHandle. as item
    $(item.type) $(item.name);
. endfor

    ~$(curFunction.handleName) () {
. for curFunction. as item where defined(item.arg)
.   if(name(item) = "send" | name(item) = "recv")
      if(NULL != $(item.name)Indices) { delete [] $(item.name)Indices; }
      if(NULL != $(item.name)Primals) { delete [] $(item.name)Primals; }
.     if(defined(item.displs))
        if(NULL != $(item.name)Count) { delete [] $(item.name)Count; }
        if(NULL != $(item.name)Displs) { delete [] $(item.name)Displs; }
.     endif
.   endif
. endfor
    }
  };

.- create the reverse function
  template<$(curFunction.tplDef)>
  void TAMPI_$(curFunction.name)_b(HandleBase* handle) {
.  unpackHandle(curFunction, 1)

.- check here if an operator exists and set the parameter for the create function
.  primalRequired = "false"
.  if(defined(curFunction->operator))
.    primalRequired = "$(curFunction->operator.name).requiresPrimalSend"
.  endif

. for curFunction.recv
.   createBufferReverseSetup(recv, curFunction, 1)
. endfor

. for curFunction.send
.   createBufferReverseSetup(send, curFunction, 0)
. endfor

    TAMPI_$(curFunction.name)_adj<$(curFunction.tplArg)>($(curFunction.argRev));

. addReverseAsyncSplit(curFunction)
. for curFunction.send
.   createBufferReverseCleanup(send, curFunction, 1)
. endfor

. for curFunction.recv
.   createBufferReverseCleanup(recv, curFunction, 0)
. endfor
  }

.--- predefine the async function
. if(defined(curFunction.async))
    template<$(curFunction.tplDef)>
    int TAMPI_$(curFunction.name)_finish(HandleBase* handle);
. endif

.-------------------------------------------------------------------------
.- create the primal function
.-------------------------------------------------------------------------
  template<$(curFunction.tplDef)>
  int TAMPI_$(curFunction.name)($(curFunction.argDef)) {
    int rStatus;
    if(!$(curFunction.adType)::IS_ActiveType) {
      // call the regular function if the type is not active
      rStatus = $(curFunction.mpiName)($(curFunction.argReg));
    } else {

      // the type is an AD type so handle the buffers
      $(curFunction.handleName)<$(curFunction.tplArg)>* h = NULL;
      // the handle is created if a reverse action should be recorded, h != NULL => tape is active
      if($(curFunction.adType)::isHandleRequired()) {
        h = new $(curFunction.handleName)<$(curFunction.tplArg)>();
      }
      $(curFunction.adType)::startAssembly(h);

.-    if there is an operator in the arguments the primals might need to be extracted
.     for curFunction.operator
        // extract the primal values for the operator if required
        if(NULL != h && op.requiresPrimal) {
.         for curFunction.send
.           createPrimalExtraction(send)
.         endfor
        }
.     endfor

.-    create the linear displacements
.     for curFunction.displs as item
        const int* $(item.name)Mod = $(item.name);
        int $(item.name)TotalSize = 0;
        if(NULL != $(item.name)) {
          $(item.name)TotalSize = computeDisplacementsTotalSize($(item.counts), getCommSize($(item.ranks)));
          if($(curFunction.mainType)::IS_RequiresModifiedBuffer) {
            $(item.name)Mod = createLinearDisplacements($(item.counts), getCommSize($(item.ranks)));
          }
        }
.     endfor

.-    create the buffers
.     for curFunction. as item where defined(item.arg)
.       if(name(item) =  "recv" | name(item) =  "send")
          typename $(item.typeName)::ModifiedType* $(item.name)Mod = NULL;
          int $(item.name)Elements = 0;

.         startRoot(item)
            // compute the total size of the buffer
.           createBufferElementsComputation(item)

.           inplace = ""
.           if(defined(item.inplace))
.             inplace = " && !(TAMPI_IN_PLACE == $(item.name))"
.           endif
            if($(item.typeName)::IS_RequiresModifiedBuffer $(inplace)) {
              $(item.name)Mod = new typename $(item.typeName)::ModifiedType[$(item.name)Elements];
            } else {
              $(item.name)Mod = reinterpret_cast<typename $(item.typeName)::ModifiedType*>(const_cast<typename $(item.typeName)::Type*>($(item.name)));
            }
.         endRoot(item)
.       endif
.     endfor

.-    copy the data into the modified buffers
.     for curFunction. as item where defined(item.arg)
.       if(name(item) = "send")
.         createBufferAccessLogic(item, 1, "$typeName$::copyIntoModifiedBuffer(&$name$[$pos$], &$name$Mod[$linPos$], $curCount$);")
.       endif
.     endfor

      if(NULL != h) {
        // gather the information for the reverse sweep

        // create the index buffers
.       for curFunction. as item where defined(item.arg)
.         if(name(item) =  "send" | name(item) =  "recv")
.           startRoot(item)
.             if(defined(item.inplace))
                if(TAMPI_IN_PLACE != $(item.name)) {
.             endif
.             if(defined(item.displs))
                createLinearIndexDisplacements(h->$(item.name)Count, h->$(item.name)Displs, $(item.count), getCommSize(comm), $(item.typeName)::IndicesPerElement);
.             else
                h->$(item.name)Count = $(item.count) * $(item.typeName)::IndicesPerElement;
.             endif
.             if(defined(item.inplace))
.               inplaceBuffer = item->inplaceBuffer
                } else {
.                if(defined(inplaceBuffer.displs))
.                  if(defined(item.displs))
                     createLinearIndexDisplacements(h->$(item.name)Count, h->$(item.name)Displs, $(inplaceBuffer.count), getCommSize(comm), $(inplaceBuffer.typeName)::IndicesPerElement);
.                  else
                     h->$(item.name)Count = $(inplaceBuffer.count)[getCommRank(comm)] * $(inplaceBuffer.typeName)::IndicesPerElement;
.                  endif
.                else
                   h->$(item.name)Count = $(inplaceBuffer.count) * $(inplaceBuffer.typeName)::IndicesPerElement;
.                endif
                }
.             endif
              h->$(item.name)TotalSize = $(item.name)Elements * $(item.typeName)::IndicesPerElement;
              h->$(item.name)Indices = new typename $(item.typeName)::IndexType[h->$(item.name)TotalSize];
.           endRoot(item)
.         endif
.       endfor

.       for curFunction. as item where defined(item.arg)
.         if(name(item) =  "send")
.-          The index buffer is always the one from the buffer we are currently handling
.           createBufferAccessLogic(item, 0, "$typeName$::getIndices(&$name$[$pos$], &h->$(item.name)Indices[$startLinPos$], $curCount$);")
.         endif
.       endfor

.       for curFunction. as item where defined(item.arg)
.         if(name(item) =  "recv")
.           createBufferAccessLogic(item, -1, "$typeName$::clearIndices(&$name$[$pos$], $curCount$);")
.         endif
.       endfor
      }

      // pack all the variables in the handle
      if(NULL != h) {
        h->func = TAMPI_$(curFunction.name)_b<$(curFunction.tplArg)>;
.-- pack the arguments (buffers are packed in buffer methods)
.       for curFunction. as item where defined(item.arg)
.         if(name(item) <> "type")
            h->$(item.name) = $(item.name);
.
.           if(name(item) = "send" | name(item) = "recv")
.
              h->$(item.name)Mod = $(item.name)Mod;
.             if(defined(item.displs))
                h->$(item.displs)Mod = $(item.displs)Mod;
.             endif
.           endif
.         endif
.       endfor
      }

      rStatus = TAMPI_$(curFunction.name)<$(curFunction.tplArgMod)>($(curFunction.argArg));
.
.     addPrimalAsyncSplit(curFunction)
.
      $(curFunction.adType)::addToolAction(h);

.-    copy the data from the modified buffers
.     for curFunction. as item where defined(item.arg)
.       if(name(item) =  "recv")
.         createBufferAccessLogic(item, 1, "$typeName$::copyFromModifiedBuffer(&$name$[$pos$], &$name$Mod[$linPos$], $curCount$);")
.       endif
.     endfor

      if(NULL != h) {
.       for curFunction. as item where defined(item.arg)
.         if(name(item) =  "recv")
.-          The index buffer is always the one from the buffer we are currently handling
.           createBufferAccessLogic(item, 0, "$typeName$::registerValue(&$name$[$pos$], &h->$(item.name)Indices[$startLinPos$], $curCount$);")
.         endif
.       endfor
      }

.     for curFunction.operator
        // extract the primal values for the operator if required
        if(NULL != h && op.requiresPrimal) {
.       for curFunction.recv
.         createPrimalExtraction(recv)
.       endfor
        }
.     endfor

      $(curFunction.adType)::stopAssembly(h);

.-    delete the linear displacements
.     for curFunction.displs as item
        if($(curFunction.mainType)::IS_RequiresModifiedBuffer) {
          delete [] $(item.name)Mod;
        }
.     endfor

.-    delete the buffers
.     for curFunction. as item where defined(item.arg)
.       if(name(item) =  "recv" | name(item) =  "send")
.         startRoot(item)
.           inplace = ""
.           if(defined(item.inplace))
.             inplace = " && !(TAMPI_IN_PLACE == $(item.name))"
.           endif
            if($(item.typeName)::IS_RequiresModifiedBuffer $(inplace)) {
              delete [] $(item.name)Mod;
            }
.         endRoot(item)
.       endif
.     endfor

      // handle is deleted by the AD tool
    }

    return rStatus;
  }

  template<>
  inline int TAMPI_$(curFunction.name)<$(curFunction.tplEmpty)>($(curFunction.argEmpty)) {
.   for curFunction. as item where defined(item.arg)
.     if(name(item) <> "type")  # exclude the types because they are handled as templates
        MEDI_UNUSED($(item.name));
.     endif
.   endfor
    return 0;
  }
.endfor
}
