.ignorecase = 0
.template 0

function modifyTypeName(type)
  return string.replace(my.type, "MPI_|TAMPI_")
endfunction

function addHandleData(handle, name, type)
  new my.handle.item
    define item.name = my.name
    define item.type = my.type
  endnew
endfunction

for functions.function as curFunction
 #generate the constants for each function
 curFunction.handleName = "TAMPI_$(curFunction.name)_Handle"
 if(!defined(curFunction.mpiName))
  curFunction.mpiName = "MPI_$(curFunction.name)"
 endif

 # mark all orignal arguments as args
 for curFunction. as item
   item.arg = 1
 endfor
 #generate the names for the datatypes
 for curFunction.send
   send.typeName = "$(send.type:upper)"
 endfor
 for curFunction.recv
   recv.typeName = "$(recv.type:upper)"
 endfor

# build the definitions for the templates
 curFunction.tplDef = ""
 curFunction.tplArg = ""
 curFunction.tplArgMod = ""
 curFunction.tplEmpty = ""
 for curFunction.type
   type.tplName = "$(type.name:upper)"
   curFunction.tplDef += "typename $(type.tplName)"
   curFunction.tplArg += "$(type.tplName)"
   curFunction.tplArgMod += "typename $(type.tplName)::ModifiedNested"
   curFunction.tplEmpty += "EmptyDataType"

   comma = last()?? "" ? ", "
   curFunction.tplDef += comma
   curFunction.tplArg += comma
   curFunction.tplArgMod += comma
   curFunction.tplEmpty += comma
 endfor

# build the TAMPI names for all arguments
 for curFunction. as item
   item.taType = modifyTypeName(item.type)
 endfor

#build the argument lists and the list for the handles
 curFunction.argDef = ""
 curFunction.argArg = ""
 curFunction.argRev = ""
 curFunction.argEmpty = ""
 for curFunction. as item where defined(item.arg)
   constMod = defined(item.const) ?? "const " ? ""
   curFunction.argDef +=   constMod # prepend the const modifier
   curFunction.argEmpty +=   constMod # prepend the const modifier
   if(name(item) <> "type")  # exclude the types because they are handled as templates
     if(name(item) =  "recv" | name(item) =  "send")
       curFunction.argDef += "typename $(item.typeName)::Type* $(item.name)"  #append '::Type' to the typename
       curFunction.argArg += "$(item.name)Mod"    # append 'Mod' to the bufferNames
       if(defined(item.displs))
         curFunction.argRev += "$(item.name)Adjoints, $(item.name)Primals, h->$(item.name)Count, h->$(item.name)Displs, $(item.name)Type"    # append adjoint and primal buffer and the byte size
       else
         curFunction.argRev += "$(item.name)Adjoints, $(item.name)Primals, $(item.name)Size, $(item.name)Type"    # append adjoint and primal buffer and the byte size
       endif
       curFunction.argEmpty += "typename EmptyDataType::Type* $(item.name)"
     elsif(name(item) = "operator")
       curFunction.argDef += "$(item.taType) $(item.name)"
       curFunction.argArg += "*$(item.name).modifiedOp"
       curFunction.argRev += "$(item.name)"
       curFunction.argEmpty += "$(item.taType) $(item.name)"
     elsif(name(item) = "displs")
       curFunction.argDef += "$(item.taType) $(item.name)"
       curFunction.argArg += "$(item.name)Mod"
       curFunction.argRev += "$(item.name)"
       curFunction.argEmpty += "$(item.taType) $(item.name)"
     else
       curFunction.argDef += "$(item.taType) $(item.name)"
       curFunction.argArg += "$(item.name)"
       curFunction.argRev += "$(item.name)"
       curFunction.argEmpty += "$(item.taType) $(item.name)"
     endif
     comma = last()?? "" ? ", "
     curFunction.argDef += comma
     curFunction.argArg += comma
     curFunction.argRev += comma
     curFunction.argEmpty += comma
   endif
 endfor

 new curFunction.primalHandle as handle
   define handle.noarg = 1
 endnew
 new curFunction.reverseHandle as handle
   define handle.noarg = 1
 endnew
 for curFunction. as item where defined(item.arg)
# TODO
 endfor

#build the argument list for the regular call
 curFunction.argReg = ""
 for curFunction. as item where defined(item.arg)

   if(name(item) = "type")
     curFunction.argReg += "$(item.tplName)::Tool::MPIType"    # get the regular mpi type
   elsif(name(item) = "operator")
     curFunction.argReg += "$(item.name).primalFunction"    # get the regular mpi type
   elsif(name(item) = "request")
     curFunction.argReg += "&$(item.name)->request"
   else
     curFunction.argReg += "$(item.name)"
   endif
   curFunction.argReg += last()?? "" ? ", "  # append the seperator if neede
 endfor

# add properties to the buffers
 for curFunction. as item where defined(item.arg)

   if(name(item) =  "recv" | name(item) =  "send")
     item.rankCount = "1"
     if(defined(item.ranks) | defined(item.displs))
       item.rankCount = "getCommSize(comm)"
     endif

   endif
 endfor

 # link inplace buffers together
 for curFunction. as item where defined(item.arg)

   if(name(item) =  "recv" | name(item) =  "send")
     if(defined(item.inplace))
       for curFunction. as linkedItem where defined(linkedItem.arg)

         if(linkedItem.name = item.inplace)
           # found the buffer with the name so copy it to this buffer and create the link
           copy linkedItem to item as inplaceBuffer
         endif
       endfor
     endif
   endif
 endfor

 # define the ad type that is used in this function
 curFunction.adType = "$(curFunction->type.tplName)::Tool"
endfor

function startRoot(buffer)
  if(defined(my.buffer.root))  # check if this buffer is only required on the root process
>      if($(my.buffer.root) == getCommRank(comm)) {
  endif
endfunction

function endRoot(buffer)
  if(defined(my.buffer.root))
>      }
  endif
endfunction

function defineBuffersMod(curFunction)
  for my.curFunction. as item where defined(item.arg)
    if(name(item) =  "recv" | name(item) =  "send")
>     typename $(item.typeName)::ModifiedType* $(item.name)Mod = NULL;
    endif
  endfor
endfunction

# define function for buffer prepare
function createBufferPrepare(buffer, type)
  # check if this is a displaced buffer
> // create the modified buffer for $(my.buffer.name) (e.g. store value, create)
  if(defined(my.buffer.displs))
>   int* $(my.buffer.displs)Mod = NULL;
  endif

  startRoot(my.buffer)
    if(defined(my.buffer.inplace))
>     if(MPI_IN_PLACE != $(my.buffer.name)) {
    endif
    if(defined(my.buffer.displs)) # call the correct routine for displacement buffers and none displacement buffers
>     $(my.buffer.typeName)::prepare$(my.type)Buffer($(my.buffer.name), $(my.buffer.count), $(my.buffer.displs), $(my.buffer.rankCount), $(my.buffer.name)Mod, $(my.buffer.displs)Mod, h->$(my.buffer.name)Indices, h->$(my.buffer.name)Count, h->$(my.buffer.name)Displs, h->$(my.buffer.name)TotalSize);
    else
>     $(my.buffer.typeName)::prepare$(my.type)Buffer($(my.buffer.name), $(my.buffer.count), $(my.buffer.rankCount), $(my.buffer.name)Mod, h->$(my.buffer.name)Indices, h->$(my.buffer.name)Count);
    endif
    if(defined(my.buffer.inplace))
>     } else {
>       $(my.buffer.name)Mod = static_cast<typename $(my.buffer.typeName)::Type*>(MPI_IN_PLACE);
        inplaceBuffer = my.buffer->inplaceBuffer
        if(defined(inplaceBuffer.displs)) # call the correct routine for displacement buffers and none displacement buffers
          if(defined(my.buffer.displs)) # call the correct routine for displacement buffers and none displacement buffers
>           $(inplaceBuffer.typeName)::prepareInplace$(my.type)Buffer($(inplaceBuffer.name), $(inplaceBuffer.count), $(inplaceBuffer.displs), $(inplaceBuffer.rankCount), getCommRank(comm), $(inplaceBuffer.name)Mod, $(inplaceBuffer.displs)Mod, h->$(my.buffer.name)Indices, h->$(my.buffer.name)Count, h->$(my.buffer.name)Displs, h->$(my.buffer.name)TotalSize);
          else
>           $(inplaceBuffer.typeName)::prepareInplace$(my.type)Buffer($(inplaceBuffer.name), $(inplaceBuffer.count), $(inplaceBuffer.displs), $(inplaceBuffer.rankCount), getCommRank(comm), $(inplaceBuffer.name)Mod, $(inplaceBuffer.displs)Mod, h->$(my.buffer.name)Indices, h->$(my.buffer.name)Count);
          endif
        else
          if(defined(my.buffer.ranks)) # call the correct routine for displacement buffers and none displacement buffers
>           $(inplaceBuffer.typeName)::prepareInplace$(my.type)Buffer($(inplaceBuffer.name), $(inplaceBuffer.count), $(inplaceBuffer.rankCount), true, getCommRank(comm), $(inplaceBuffer.name)Mod, h->$(my.buffer.name)Indices, h->$(my.buffer.name)Count);
          else
>           $(inplaceBuffer.typeName)::prepareInplace$(my.type)Buffer($(inplaceBuffer.name), $(inplaceBuffer.count), $(inplaceBuffer.rankCount), false, getCommRank(comm), $(inplaceBuffer.name)Mod, h->$(my.buffer.name)Indices, h->$(my.buffer.name)Count);
          endif
        endif
>     }
    endif
  endRoot(my.buffer)
endfunction

# define function for buffer handle
function createBufferHandle(buffer, type)
> // handle the modified buffer for $(my.buffer.name) (e.g. extract values, delete)
  startRoot(my.buffer)
    if(defined(my.buffer.inplace))
>     if(MPI_IN_PLACE != $(my.buffer.name)) {
    endif
    if(defined(my.buffer.displs)) # call the correct routine for displacement buffers and none displacement buffers
>     $(my.buffer.typeName)::handle$(my.type)Buffer($(my.buffer.name), $(my.buffer.count), $(my.buffer.displs), $(my.buffer.rankCount), $(my.buffer.name)Mod, $(my.buffer.displs)Mod, h->$(my.buffer.name)Indices, h->$(my.buffer.name)Count, h->$(my.buffer.name)Displs, h->$(my.buffer.name)TotalSize);
    else
>     $(my.buffer.typeName)::handle$(my.type)Buffer($(my.buffer.name), $(my.buffer.count), $(my.buffer.rankCount), $(my.buffer.name)Mod, h->$(my.buffer.name)Indices, h->$(my.buffer.name)Count);
    endif
    if(defined(my.buffer.inplace))
>     }
    endif
  endRoot(my.buffer)
endfunction

function createBufferReverseSetup(buffer, curFunction, isRecv)
> $(my.buffer.name)Adjoints = NULL;
> $(my.buffer.name)Primals = NULL;
> int $(my.buffer.name)Size = 0;
  if(defined(my.buffer.displs))
>   int $(my.buffer.name)TotalSize = h->$(my.buffer.name)TotalSize;
  else
>   int $(my.buffer.name)TotalSize = h->$(my.buffer.name)Count * $(my.buffer.rankCount);
  endif
> MPI_Datatype $(my.buffer.name)Type = MPI_DOUBLE;
  startRoot(my.buffer)
    allMul = ""
    if(defined(my.buffer.all))
      allMul = "* getCommSize($(my.buffer.all))"
    endif
>   allocateReverseBuffer($(my.buffer.name)Adjoints, $(my.buffer.name)Primals, h->$(my.buffer.name)Count, $(my.buffer.name)TotalSize $(allMul), $(primalRequired), $(my.buffer.name)Size, $(my.buffer.name)Type);
    if(1 = my.isRecv)
>     $(my.buffer.typeName)::getAdjoints(h->$(my.buffer.name)Indices, $(my.buffer.name)TotalSize, $(my.buffer.name)Adjoints);
>
      if(defined(my.curFunction->operator))
>       $(my.curFunction->operator.name).preAdjointOperation($(my.buffer.name)Adjoints, h->$(my.buffer.name)Primals, h->$(my.buffer.name)Count);
>       if($(primalRequired)) {
>         copyPrimals($(my.buffer.name)Primals, h->$(my.buffer.name)Primals, h->$(my.buffer.name)Count);
>       }
      endif
    endif
  endRoot(my.buffer)
endfunction

function createBufferReverseCleanup(buffer, curFunction, isSend)
  startRoot(my.buffer)
    if(1 = my.isSend)
      if(defined(my.curFunction->operator))
>       $(my.curFunction->operator.name).postAdjointOperation($(my.buffer.name)Adjoints, h->$(my.buffer.name)Primals, $(my.buffer.name)Primals, $(my.buffer.name)TotalSize);
      endif
      if(defined(my.buffer.all))
>       combineAdjoints($(my.buffer.name)TotalSize, $(my.buffer.name)Adjoints, getCommSize($(my.buffer.all)));
      endif
>     $(my.buffer.typeName)::updateAdjoints(h->$(my.buffer.name)Indices, $(my.buffer.name)TotalSize, $(my.buffer.name)Adjoints);
    endif
>   deleteReverseBuffer($(my.buffer.name)Adjoints , $(my.buffer.name)Primals, $(primalRequired));
  endRoot(my.buffer)
endfunction

# define function for primal extraction
function createPrimalExtraction(buffer)
  startRoot(my.buffer)
>   const typename $(my.buffer.typeName)::Type* tempBuf = $(my.buffer.name);
    if(defined(my.buffer.inplace))
>     if(MPI_IN_PLACE == tempBuf) {
>       tempBuf = $(my.buffer.inplace);
>     }
    endif
>   $(my.buffer.typeName)::getValues(tempBuf, $(my.buffer.count), h->$(my.Buffer.name)Primals);
  endRoot(my.buffer)
endfunction

function unpackHandle(curFunction, reverse)
>   $(my.curFunction.handleName)<$(my.curFunction.tplArg)>* h = static_cast<$(my.curFunction.handleName)<$(my.curFunction.tplArg)>*>(handle);
# unpack the arguments (buffers are accessed directly)
  for my.curFunction. as item where defined(item.arg)
    if(name(item) <> "type")
      constMod = defined(item.const) ?? "const " ? ""
      if(name(item) = "send" | name(item) = "recv")
        if(1 = my.reverse)
>        typename $(item.typeName)::PassiveType* $(item.name)Adjoints = h->$(item.name)Adjoints;
>        typename $(item.typeName)::PassiveType* $(item.name)Primals = h->$(item.name)PrimalsReverse;
        else
>        $(constMod)typename $(item.typeName)::Type* $(item.name) = h->$(item.name);
>        typename $(item.typeName)::ModifiedType* $(item.name)Mod = h->$(item.name)Mod;
         if(defined(item.displs))
>         int* $(item.displs)Mod = h->$(item.displs)Mod;
         endif
        endif
      elsif(name(item) = "request")
        if(1 = my.reverse)
>         $(item.taType) $(item.name) = &h->$(item.name)Reverse;
        else
>         $(item.taType) $(item.name) = h->$(item.name);
        endif
      else
>         $(constMod)$(item.taType) $(item.name) = h->$(item.name);
      endif
    endif
  endfor
endfunction

function packHandle(curFunction, reverse)
# pack the arguments
  for my.curFunction->handle. as item
    if(1 = my.reverse)
      out = item.reverse
    else
      out = item.primal
    endif

    if(out)
>     h->$(item.name) = $(item.name);
    endif
  endfor
endfunction

function addPrimalAsyncSplit(curFunction)
  if(defined(my.curFunction.async))
>      $(my.curFunction.async)->handle = h;
>      $(my.curFunction.async)->func = (ContinueFunction)TAMPI_$(my.curFunction.name)_finish<$(my.curFunction.tplArg)>;
>      if(NULL != h) {
>        WaitHandle* waitH = new WaitHandle((ContinueFunction)TAMPI_$(my.curFunction.name)_b_finish<$(my.curFunction.tplArg)>, h);
>        $(my.curFunction.adType)::addToolAction(waitH);
>      }
>    }
>
>    return rStatus;
>  }
>
>  template<$(my.curFunction.tplDef)>
>  int TAMPI_$(my.curFunction.name)_finish(HandleBase* handle) {
>    int rStatus = 0;
>    if($(my.curFunction.adType)::IS_ActiveType) {
    unpackHandle(my.curFunction, 0)
>
  endif
endfunction

function addReverseAsyncSplit(curFunction)
  if(defined(my.curFunction.async))
  for my.curFunction. as item
    if(name(item) = "send" | name(item) = "recv")
>     h->$(item.name)Adjoints = $(item.name)Adjoints;
>     h->$(item.name)PrimalsReverse = $(item.name)Primals;
    endif
  endfor
>  }
>
>  template<$(my.curFunction.tplDef)>
>  void TAMPI_$(my.curFunction.name)_b_finish(HandleBase* handle) {
    unpackHandle(my.curFunction, 1)
    for my.curFunction. as item
      if(name(item) = "send" | name(item) = "recv")
        if(defined(item.displs))
>         int $(item.name)TotalSize = h->$(item.name)TotalSize;
        else
>         int $(item.name)TotalSize = h->$(item.name)Count * $(item.rankCount);
        endif
      endif
    endfor
>
>    MPI_Wait(&$(my.curFunction.async)->request, MPI_STATUS_IGNORE);
>
  endif
endfunction

.endtemplate
.output "$(switches.arg1)"
#pragma once

#include "../include/medipack.h"
#include "../include/reverseFunctions.hpp"
#include "../include/tampi/async.hpp"

namespace medi {
.for functions.function as curFunction
.- create the struct for the data store
  template<$(curFunction.tplDef)>
  struct $(curFunction.handleName) : public HandleBase {
. for curFunction. as item where defined(item.arg)
.   if(name(item) <> "type")
.     constMod = defined(item.const) ?? "const " ? ""
.     if(name(item) = "send" | name(item) = "recv")
        $(constMod)typename $(item.typeName)::Type* $(item.name);  // required for async requests
        typename $(item.typeName)::ModifiedType* $(item.name)Mod;  // required for async requests
        typename $(item.typeName)::IndexType* $(item.name)Indices;
        typename $(item.typeName)::PassiveType* $(item.name)Primals;
        typename $(item.typeName)::PassiveType* $(item.name)Adjoints;  // required for async requests
        typename $(item.typeName)::PassiveType* $(item.name)PrimalsReverse;  // required for async requests
.        if(defined(item.displs))
          int* $(item.name)Count;
          int* $(item.name)Displs;
          int $(item.name)TotalSize;
          int* $(item.displs)Mod;
.        else
          int $(item.name)Count;
.        endif
.     elsif(name(item) = "request")
        $(item.taType) $(item.name);
        TAMPI_Request $(item.name)Reverse;
.     else
        $(constMod)$(item.taType) $(item.name);
.     endif
.   endif
. endfor

    ~$(curFunction.handleName) () {
. for curFunction. as item where defined(item.arg)
.   if(name(item) = "send" | name(item) = "recv")
      if(NULL != $(item.name)Indices) { delete [] $(item.name)Indices; }
      if(NULL != $(item.name)Primals) { delete [] $(item.name)Primals; }
.     if(defined(item.displs))
        if(NULL != $(item.name)Count) { delete [] $(item.name)Count; }
        if(NULL != $(item.name)Displs) { delete [] $(item.name)Displs; }
.     endif
.   endif
. endfor
    }
  };

.- create the reverse function
  template<$(curFunction.tplDef)>
  void TAMPI_$(curFunction.name)_b(HandleBase* handle) {
.  unpackHandle(curFunction, 1)

.- check here if an operator exists and set the parameter for the create function
.  primalRequired = "false"
.  if(defined(curFunction->operator))
.    primalRequired = "$(curFunction->operator.name).requiresPrimalSend"
.  endif

. for curFunction.recv
.   createBufferReverseSetup(recv, curFunction, 1)
. endfor

. for curFunction.send
.   createBufferReverseSetup(send, curFunction, 0)
. endfor

    TAMPI_$(curFunction.name)_adj<$(curFunction.tplArg)>($(curFunction.argRev));

. addReverseAsyncSplit(curFunction)
. for curFunction.send
.   createBufferReverseCleanup(send, curFunction, 1)
. endfor

. for curFunction.recv
.   createBufferReverseCleanup(recv, curFunction, 0)
. endfor
  }

.--- predefine the async function
. if(defined(curFunction.async))
    template<$(curFunction.tplDef)>
    int TAMPI_$(curFunction.name)_finish(HandleBase* handle);
. endif

.-------------------------------------------------------------------------
.- create the primal function
.-------------------------------------------------------------------------
  template<$(curFunction.tplDef)>
  int TAMPI_$(curFunction.name)($(curFunction.argDef)) {
    int rStatus;
    if(!$(curFunction.adType)::IS_ActiveType) {
      // call the regular function if the type is not active
      rStatus = $(curFunction.mpiName)($(curFunction.argReg));
    } else {

.     defineBuffersMod(curFunction)
      // the type is an AD type so handle the buffers
      $(curFunction.handleName)<$(curFunction.tplArg)>* h = NULL;
      // the handle is created if a reverse action should be recorded, h != NULL => tape is active
      if($(curFunction.adType)::isHandleRequired()) {
        h = new $(curFunction.handleName)<$(curFunction.tplArg)>();
      }
      $(curFunction.adType)::startAssembly(h);

.-    if there is an operator in the arguments the primals might need to be extracted
.     for curFunction.operator
        // extract the primal values for the operator if required
        if(NULL != h && op.requiresPrimal) {
.         for curFunction.send
.           createPrimalExtraction(send)
.         endfor
        }
.     endfor

.- TODO: for index deletion reverse this again and add an extra loop that creates the temporary buffers
.     for curFunction.recv
.       createBufferPrepare(recv, "Recv")
.     endfor

.     for curFunction.send
.       createBufferPrepare(send, "Send")
.     endfor

      // pack all the variables in the handle
      if(NULL != h) {
        h->func = TAMPI_$(curFunction.name)_b<$(curFunction.tplArg)>;
.-- pack the arguments (buffers are packed in buffer methods)
.       for curFunction. as item where defined(item.arg)
.         if(name(item) <> "type")
            h->$(item.name) = $(item.name);
.
.           if(name(item) = "send" | name(item) = "recv")
.
              h->$(item.name)Mod = $(item.name)Mod;
.             if(defined(item.displs))
                h->$(item.displs)Mod = $(item.displs)Mod;
.             endif
.           endif
.         endif
.       endfor
      }

      rStatus = TAMPI_$(curFunction.name)<$(curFunction.tplArgMod)>($(curFunction.argArg));
.
.     addPrimalAsyncSplit(curFunction)
.
      $(curFunction.adType)::addToolAction(h);

.     for curFunction.send
.       createBufferHandle(send, "Send")
.     endfor

.     for curFunction.recv
.       createBufferHandle(recv, "Recv")
.     endfor

.     for curFunction.operator
        // extract the primal values for the operator if required
        if(NULL != h && op.requiresPrimal) {
.       for curFunction.recv
.         createPrimalExtraction(recv)
.       endfor
        }
.     endfor

      $(curFunction.adType)::stopAssembly(h);

      // handle is deleted by the AD tool
    }

    return rStatus;
  }

  template<>
  inline int TAMPI_$(curFunction.name)<$(curFunction.tplEmpty)>($(curFunction.argEmpty)) {
.   for curFunction. as item where defined(item.arg)
.     if(name(item) <> "type")  # exclude the types because they are handled as templates
        MEDI_UNUSED($(item.name));
.     endif
.   endfor
    return 0;
  }
.endfor
}
